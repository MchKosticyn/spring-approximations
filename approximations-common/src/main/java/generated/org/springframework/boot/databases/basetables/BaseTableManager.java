package generated.org.springframework.boot.databases.basetables;

import generated.org.springframework.boot.databases.CacheTable;
import generated.org.springframework.boot.databases.FiltredTable;
import generated.org.springframework.boot.databases.ITable;
import generated.org.springframework.boot.databases.MappedTable;
import generated.org.springframework.boot.databases.utils.DTOInfo;
import org.usvm.api.Engine;
import org.usvm.spring.api.SpringEngine;

import java.lang.reflect.Array;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

public class BaseTableManager<T, V> implements ITableManager<T> {

    private Class<V> idType;  // null iff id is complex

    private BaseTable<T> baseTable;
    private ABaseTable<T> tablesChain;

    private final String tableName;

    private boolean isAutoGenerateId;

    private String[] fieldsToValidateNames;

    private Map<String, Function<T, Object>> getters; // field name <-> getter
    private Map<String, BiConsumer<T, Object>> setters; // field name <-> setter

    private Function<T, T> copyFunction;

    public BaseTableManager(String tableName) {
        this.tableName = tableName;
    }

    private DTOInfo<T, V> dtoInfo = null;

    @SuppressWarnings("unchecked")
    public void initialize(DTOInfo<T, V> dtoInfo) {
        if (this.dtoInfo != null) return;

        this.dtoInfo = dtoInfo;
        this.idType = dtoInfo.getIdType();
        this.fieldsToValidateNames = dtoInfo.getFieldsToValidateNames();
        this.isAutoGenerateId = dtoInfo.isAutoGeneratedId();

        Class<T> entityType = dtoInfo.getEntityType();
        this.baseTable = new BaseTable<>(entityType, isAutoGenerateId);
        this.tablesChain = this.baseTable;

        if (!isAutoGenerateId) applyIdValidation();
        applyFieldsValidation(fieldsToValidateNames);

        if (dtoInfo.isNeedTrack()) applyTrack(tableName, entityType);

        // DTO functions
        this.baseTable.setDTOFunctions(
                dtoInfo.getBlankInit(),
                dtoInfo.getRelationsInit(),
                dtoInfo.getBuildIdFunction(),
                dtoInfo.getGetIdFunction(),
                dtoInfo.getSetIdFunction()
        );

        // Setters and getters
        String[] fieldNames = dtoInfo.getFieldsNames();
        this.getters = new HashMap<>();
        this.setters = new HashMap<>();
        for (int i = 0; i < fieldNames.length; i++) {
            this.getters.put(fieldNames[i], dtoInfo.getGetters()[i]);
            this.setters.put(fieldNames[i], dtoInfo.getSetters()[i]);
        }

        this.copyFunction = dtoInfo.getCopyFunction();

        String[] fieldsToSoftNames = dtoInfo.getFieldsToSoftNames();
        Class<?>[] fieldsToSoftTypes = dtoInfo.getFieldsToSoftTypes();
        Function<T, Object>[] softGetters =
                (Function<T, Object>[]) Array.newInstance(Function.class, fieldsToSoftNames.length);
        for (int i = 0; i < fieldsToSoftNames.length; i++) {
            softGetters[i] = this.getters.get(fieldsToSoftNames[i]);
        }
        this.baseTable.setForSoft(softGetters, fieldsToSoftTypes);
    }

    public boolean isInitialized() { return dtoInfo != null; }

    public DTOInfo<T, V> getDTOInfo() { return dtoInfo; }

    private void checkInitialized() {
        if (!isInitialized()) SpringEngine.println("[DB Warning] BaseTableManager is not initialized");
    }

    private void applyIdValidation() {
        this.tablesChain = new BaseTableCommonId<>(this.tablesChain);
    }

    private void applyFieldsValidation(String[] fieldsToValidateNames) {
        this.tablesChain = new BaseTableConstraintValidate<>(this.tablesChain, fieldsToValidateNames);
    }

    private void applyTrack(String tableName, Class<T> entityType) {
        this.tablesChain = new BaseTableTrack<>(this.tablesChain, tableName, entityType);
    }

    // used only for relations init
    public ITable<T> getTable() {
        checkInitialized();
        return tablesChain;
    }

    // common table access
    public ITable<T> getCopiedTable() {
        checkInitialized();
        return new MappedTable<>(tablesChain, copyFunction);
    }

    public Class<V> getIdType() {
        checkInitialized();
        return idType;
    }

    public boolean isAutoGenerateId() {
        return isAutoGenerateId;
    }

    public CacheTable<T> getValuesWithId(Object[] values) {
        checkInitialized();
        Function<T, Boolean> filter = (T t) -> {
            Object[] id = buildId(t);
            for (int i = 0; i < values.length; i++) {
                if (!id[i].equals(values[i])) return false;
            }

            return true;
        };

        FiltredTable<T> filtred = new FiltredTable<>(getTable(), filter);
        return new CacheTable<>(filtred);
    }

    public CacheTable<T> getValuesWithFields(Object[] values, String[] names) {
        checkInitialized();
        Function<T, Boolean> filter = (T t) -> {
            for (int i = 0; i < values.length; i++) {
                Object value = values[i];
                Object tField = getters.get(names[i]).apply(t);
                if (!value.equals(tField)) return false;
            }

            return true;
        };

        FiltredTable<T> entities = new FiltredTable<>(getTable(), filter);
        return new CacheTable<>(entities);
    }

    public CacheTable<T> getValuesRelatedByTable(
            Object[] value, // parent id

            // ixs of columns that relate parent table
            NoIdTableManager addTable,
            int[] joinTableIxs,
            int[] otherIxs
    ) {
        checkInitialized();
        // take from manytomany table   | p_id | c_id |
        // al rows that p_id == value (given parent id)
        Function<Object[], Boolean> filter = (Object[] row) -> {
            for (int i = 0; i < value.length; i++) {
                Object id = value[i];
                Object rowId = row[joinTableIxs[i]];
                if (!id.equals(rowId)) {
                    Engine.assume(false);
                    return false;
                }
            }

            return true;
        };

        // take from this tableChain all rows whose id values
        // are contained in filtered manytomany table
        Function<Object[], T> map = (Object[] row) -> {
            Object[] values = new Object[otherIxs.length];
            for (int i = 0; i < otherIxs.length; i++) {
                values[i] = row[otherIxs[i]];
            }

            return getValuesWithId(values).ensureFirst();
        };

        MappedTable<Object[], T> entities = new MappedTable<>(
                new FiltredTable<>(
                        addTable,
                        filter
                ),
                map
        );
        return new CacheTable<>(entities);
    }

    @Override
    public void applyRangeUpdate(Function<T, Boolean> predicate, Function<T, T> update) {
        checkInitialized();
        tablesChain = new RangeUpdatedTable<>(tablesChain, predicate, update, fieldsToValidateNames);
    }

    @Override
    public void applyRangeDelete(Function<T, Boolean> predicate) {
        checkInitialized();
        tablesChain = new RangeDeletedTable<>(tablesChain, predicate);
    }

    public void changeFieldsByIdEnsure(Object[] id, String[] fields, Object[] values) {
        checkInitialized();
        Consumer<T> update = (T t) -> {
            for (int i = 0; i < fields.length; i++) {
                BiConsumer<T, Object> setter = setters.get(fields[i]);
                setter.accept(t, values[i]);
            }
        };

        tablesChain = new BaseTableEnsureSingleUpdate<>(tablesChain, id, update);
    }

    public void pureSave(T t) {
        checkInitialized();
        if (isAutoGenerateId) {
            baseTable.setNewGeneratedId(t);
        }

        tablesChain = new BaseTablePureSave<>(tablesChain, t);
    }

    public Object[] buildId(T t) {
        checkInitialized();
        return tablesChain.buildId(t);
    }

    public Optional<T> findById(Object[] key) {
        checkInitialized();
        for (T t : getCopiedTable()) {
            Object[] tId = buildId(t);

            boolean equals = true;
            for (int i = 0; i < key.length; i++) {
                if (!key[i].equals(tId[i])) {
                    equals = false;
                    break;
                }
            }

            if (equals) return Optional.of(t);
        }
        return Optional.empty();
    }

    public void save(T t) {
        checkInitialized();
        if (isAutoGenerateId) {
            baseTable.setNewGeneratedId(t);
        }

        tablesChain = new BaseTableSave<>(tablesChain, t);
    }

    public void delete(T t) {
        checkInitialized();
        tablesChain = new BaseTableDelete<>(tablesChain, t);
    }

    public void deleteAll() {
        checkInitialized();
        applyRangeDelete((T t) -> true);
    }
}
